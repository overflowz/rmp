"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("debug"),t=require("ulid"),r=require("rxjs"),a=require("rxjs/operators");function s(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var o,n=s(e);(o=exports.PacketType||(exports.PacketType={}))[o.Request=0]="Request",o[o.Response=1]="Response",o[o.Broadcast=2]="Broadcast";class i extends Error{constructor(e,t){super(e),this.name="TryCatchError",this.origin=t,"function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this)}static from(e){return new i(e.message,e)}}const c=e=>{try{const t=e();return"function"==typeof t?.then?t.catch((e=>i.from(e instanceof Error?e:new Error(e)))):t}catch(e){return i.from(e instanceof Error?e:new Error(e))}},p="@overflowz/rmp:core",l=t.monotonicFactory();exports.RMP=class{constructor(e,t){this.channel=e,this.adapter=t,this.messageStream$=new r.Subject,this.adapter.subClient.onMessage(this.onMessage.bind(this))}static async connect({channel:e,subscribeTo:t,adapter:r}){const a=new this(e,r),s=[...new Set([e,...t??[]])];return await Promise.all(s.map((e=>r.subClient.subscribe(e)))),a}onMessage(e,t){const r=n.default(p+":onMessage"),a=c((()=>JSON.parse(t)));if(a instanceof Error)return void r("unable to parse the packet: %j",{packet:a});const{type:s,headers:o}=a;void 0!==exports.PacketType[s]?void 0!==o?.correlationId?s!==exports.PacketType.Request||void 0!==o?.responseChannel?s!==exports.PacketType.Broadcast||e!==this.channel?this.messageStream$.next({channel:e,packet:a}):r("ignoring the own broadcast message"):r("missing responseChannel in the request packet: %j",{packet:a}):r("missing correlationId in the packet header: %j",{packet:a}):r(`invalid packet type (${s}) received: %j`,{packet:a,type:s})}getMessageStream(e){return this.messageStream$.pipe(a.filter((t=>t.channel===e)),a.map((e=>e.packet)))}async reply(e,t){const r=n.default(p+":reply"),{correlationId:a,responseChannel:s}=e.headers,o={correlationId:a},i={type:exports.PacketType.Response,headers:o,payload:t},l=await c((()=>this.adapter.pubClient.publish(s,JSON.stringify(i))));return l instanceof Error?(r("error publishing the packet: %j",{packet:i,publish:l}),Promise.reject(l.origin)):Promise.resolve()}async broadcast(e){const t=n.default(p+":broadcast"),r={correlationId:l()},a={type:exports.PacketType.Broadcast,headers:r,payload:e},s=await c((()=>this.adapter.pubClient.publish(this.channel,JSON.stringify(a))));return s instanceof Error?(t("error publishing the packet: %j",{packet:a,publish:s}),Promise.reject(s.origin)):Promise.resolve()}request(e,t,s){const o=n.default(p+":request"),i=l(),h={correlationId:i,responseChannel:this.channel},u={type:exports.PacketType.Request,headers:h,payload:t},d=r.defer((async()=>{const t=await c((()=>this.adapter.pubClient.publish(e,JSON.stringify(u))));return t instanceof Error?(o("error publishing the packet: %j",{publish:t,packet:u}),Promise.reject(t.origin)):Promise.resolve()}));return r.combineLatest([this.getMessageStream(this.channel),d]).pipe(a.timeoutWith(s??3e4,r.throwError(new Error("ERROR_REQUEST_TIMEOUT"))),a.map((([e])=>e)),a.filter((e=>e.type===exports.PacketType.Response&&e.headers.correlationId===i)),a.first(),a.map((e=>e.payload))).toPromise()}onRequest(e){if(void 0!==this.onRequestCallback)throw new Error("cannot call onRequest more than once");this.onRequestCallback=e,this.getMessageStream(this.channel).pipe(a.filter((e=>e.type===exports.PacketType.Request)),a.mergeMap((e=>r.combineLatest([r.of(e),r.defer((async()=>this.onRequestCallback?.(this.channel,e.payload)))]))),a.mergeMap((([e,t])=>r.defer((async()=>c((()=>this.reply(e,t)))))))).subscribe()}onBroadcast(e){if(void 0!==this.onBroadcastCallback)throw new Error("cannot call onBroadcast more than once");this.onBroadcastCallback=e,this.messageStream$.pipe(a.filter((e=>e.packet.type===exports.PacketType.Broadcast)),a.tap((({channel:e,packet:t})=>this.onBroadcastCallback?.(e,t.payload)))).subscribe()}};
//# sourceMappingURL=index.js.map
