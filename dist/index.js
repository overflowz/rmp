"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("debug"),t=require("ulid"),r=require("rxjs"),s=require("rxjs/operators");function a(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var o,n=a(e);(o=exports.PacketType||(exports.PacketType={}))[o.Request=0]="Request",o[o.Response=1]="Response",o[o.Broadcast=2]="Broadcast";class i extends Error{constructor(e,t){super(e),this.name="TryCatchError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this)}static from(e){return new i(e.message,e)}}const c=e=>{try{const t=e();return"function"==typeof t?.then?t.catch((e=>i.from(e instanceof Error?e:new Error(e)))):t}catch(e){return i.from(e instanceof Error?e:new Error(e))}};class p extends Error{constructor(e){super(e),this.name="ResponseError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this)}static from(e){return new p(e.message)}}const h="@overflowz/rmp:core",u=t.monotonicFactory();exports.RMP=class{constructor(e,t){this.channel=e,this.adapter=t,this.onRequestCallback=()=>{},this.onBroadcastCallback=()=>{},this.messageStream$=new r.Subject,this.onMessage=this.onMessage.bind(this),this.request=this.request.bind(this),this.broadcast=this.broadcast.bind(this),this.onRequest=this.onRequest.bind(this),this.onBroadcast=this.onBroadcast.bind(this),this.adapter.subClient.onMessage(this.onMessage)}static async connect({channel:e,subscribeTo:t,adapter:r}){const s=new this(e,r),a=[...new Set([e,...t??[]])];return await Promise.all(a.map((e=>r.subClient.subscribe(e)))),s}onMessage(e,t){const r=n.default(h+":onMessage"),s=c((()=>JSON.parse(t)));if(s instanceof Error)return void r("unable to parse the packet: %j",{packet:s});const{type:a,headers:o}=s;void 0!==exports.PacketType[a]?void 0!==o?.correlationId?a!==exports.PacketType.Request||void 0!==o?.responseChannel?a!==exports.PacketType.Broadcast||e!==this.channel?this.messageStream$.next({channel:e,packet:s}):r("ignoring the own broadcast message"):r("missing responseChannel in the request packet: %j",{packet:s}):r("missing correlationId in the packet header: %j",{packet:s}):r(`invalid packet type (${a}) received: %j`,{packet:s,type:a})}getMessageStream(e){return this.messageStream$.pipe(s.filter((t=>t.channel===e)),s.map((e=>e.packet)))}async reply(e,t){const r=n.default(h+":reply"),{correlationId:s,responseChannel:a}=e.headers,o={correlationId:s,isErrorResponse:t instanceof Error},i={type:exports.PacketType.Response,headers:o,payload:t instanceof Error?t.message:t},p=await c((()=>this.adapter.pubClient.publish(a,JSON.stringify(i))));return p instanceof Error?(r("error publishing the packet: %j",{packet:i,publish:p}),Promise.reject(p.origin)):Promise.resolve()}async broadcast(e){const t=n.default(h+":broadcast"),r={correlationId:u()},s={type:exports.PacketType.Broadcast,headers:r,payload:e},a=await c((()=>this.adapter.pubClient.publish(this.channel,JSON.stringify(s))));return a instanceof Error?(t("error publishing the packet: %j",{packet:s,publish:a}),Promise.reject(a.origin)):Promise.resolve()}request(e,t,a){const o=n.default(h+":request"),i=u(),l={correlationId:i,responseChannel:this.channel},d={type:exports.PacketType.Request,headers:l,payload:t},b=r.defer((async()=>{const t=await c((()=>this.adapter.pubClient.publish(e,JSON.stringify(d))));return t instanceof Error?(o("error publishing the packet: %j",{publish:t,packet:d}),Promise.reject(t.origin)):Promise.resolve()}));return r.of(null).pipe(s.timeoutWith(a??3e4,r.throwError(new Error("ERROR_REQUEST_TIMEOUT"))),s.mergeMap((()=>r.combineLatest([this.getMessageStream(this.channel).pipe(s.filter((e=>e.type===exports.PacketType.Response&&e.headers.correlationId===i))),b]))),s.map((([e])=>e)),s.first(),s.mergeMap((e=>e.headers.isErrorResponse?r.throwError("string"==typeof e.payload?new p(e.payload):new Error("ERROR_INVALID_RESPONSE")):r.of(e))),s.map((e=>e.payload))).toPromise()}get onRequest(){return this.onRequestCallback}set onRequest(e){this.onRequestCallback=e,this.onRequestSubscription?.unsubscribe(),this.onRequestSubscription=this.getMessageStream(this.channel).pipe(s.filter((e=>e.type===exports.PacketType.Request)),s.mergeMap((e=>r.combineLatest([r.of(e),r.defer((async()=>c((()=>this.onRequestCallback?.(this.channel,e.payload)))))]))),s.mergeMap((([e,t])=>r.defer((async()=>c((()=>this.reply(e,t)))))))).subscribe()}get onBroadcast(){return this.onBroadcastCallback}set onBroadcast(e){this.onBroadcastCallback=e,this.onBroadcastSubscription?.unsubscribe(),this.onBroadcastSubscription=this.messageStream$.pipe(s.filter((e=>e.packet.type===exports.PacketType.Broadcast)),s.tap((({channel:e,packet:t})=>this.onBroadcastCallback?.(e,t.payload)))).subscribe()}},exports.ResponseError=p;
//# sourceMappingURL=index.js.map
