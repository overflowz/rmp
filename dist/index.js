"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("debug"),t=require("ulid"),r=require("rxjs"),s=require("rxjs/operators");function a(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var o,n=a(e);(o=exports.PacketType||(exports.PacketType={}))[o.Request=0]="Request",o[o.Response=1]="Response",o[o.Broadcast=2]="Broadcast";class i extends Error{constructor(e,t){super(e),this.name="TryCatchError",this.origin=t,"function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this)}static from(e){return new i(e.message,e)}}const c=e=>{try{const t=e();return"function"==typeof t?.then?t.catch((e=>i.from(e instanceof Error?e:new Error(e)))):t}catch(e){return i.from(e instanceof Error?e:new Error(e))}},p="@overflowz/rmp:core",h=t.monotonicFactory();exports.RMP=class{constructor(e,t){this.channel=e,this.adapter=t,this.messageStream$=new r.Subject,this.onMessage=this.onMessage.bind(this),this.request=this.request.bind(this),this.broadcast=this.broadcast.bind(this),this.onRequest=this.onRequest.bind(this),this.onBroadcast=this.onBroadcast.bind(this),this.adapter.subClient.onMessage(this.onMessage)}static async connect({channel:e,subscribeTo:t,adapter:r}){const s=new this(e,r),a=[...new Set([e,...t??[]])];return await Promise.all(a.map((e=>r.subClient.subscribe(e)))),s}onMessage(e,t){const r=n.default(p+":onMessage"),s=c((()=>JSON.parse(t)));if(s instanceof Error)return void r("unable to parse the packet: %j",{packet:s});const{type:a,headers:o}=s;void 0!==exports.PacketType[a]?void 0!==o?.correlationId?a!==exports.PacketType.Request||void 0!==o?.responseChannel?a!==exports.PacketType.Broadcast||e!==this.channel?this.messageStream$.next({channel:e,packet:s}):r("ignoring the own broadcast message"):r("missing responseChannel in the request packet: %j",{packet:s}):r("missing correlationId in the packet header: %j",{packet:s}):r(`invalid packet type (${a}) received: %j`,{packet:s,type:a})}getMessageStream(e){return this.messageStream$.pipe(s.filter((t=>t.channel===e)),s.map((e=>e.packet)))}async reply(e,t){const r=n.default(p+":reply"),{correlationId:s,responseChannel:a}=e.headers,o={correlationId:s},i={type:exports.PacketType.Response,headers:o,payload:t},h=await c((()=>this.adapter.pubClient.publish(a,JSON.stringify(i))));return h instanceof Error?(r("error publishing the packet: %j",{packet:i,publish:h}),Promise.reject(h.origin)):Promise.resolve()}async broadcast(e){const t=n.default(p+":broadcast"),r={correlationId:h()},s={type:exports.PacketType.Broadcast,headers:r,payload:e},a=await c((()=>this.adapter.pubClient.publish(this.channel,JSON.stringify(s))));return a instanceof Error?(t("error publishing the packet: %j",{packet:s,publish:a}),Promise.reject(a.origin)):Promise.resolve()}request(e,t,a){const o=n.default(p+":request"),i=h(),l={correlationId:i,responseChannel:this.channel},u={type:exports.PacketType.Request,headers:l,payload:t},d=r.defer((async()=>{const t=await c((()=>this.adapter.pubClient.publish(e,JSON.stringify(u))));return t instanceof Error?(o("error publishing the packet: %j",{publish:t,packet:u}),Promise.reject(t.origin)):Promise.resolve()}));return r.combineLatest([this.getMessageStream(this.channel),d]).pipe(s.timeoutWith(a??3e4,r.throwError(new Error("ERROR_REQUEST_TIMEOUT"))),s.map((([e])=>e)),s.filter((e=>e.type===exports.PacketType.Response&&e.headers.correlationId===i)),s.first(),s.map((e=>e.payload))).toPromise()}onRequest(e){if(void 0!==this.onRequestCallback)throw new Error("cannot call onRequest more than once");this.onRequestCallback=e,this.getMessageStream(this.channel).pipe(s.filter((e=>e.type===exports.PacketType.Request)),s.mergeMap((e=>r.combineLatest([r.of(e),r.defer((async()=>this.onRequestCallback?.(this.channel,e.payload)))]))),s.mergeMap((([e,t])=>r.defer((async()=>c((()=>this.reply(e,t)))))))).subscribe()}onBroadcast(e){if(void 0!==this.onBroadcastCallback)throw new Error("cannot call onBroadcast more than once");this.onBroadcastCallback=e,this.messageStream$.pipe(s.filter((e=>e.packet.type===exports.PacketType.Broadcast)),s.tap((({channel:e,packet:t})=>this.onBroadcastCallback?.(e,t.payload)))).subscribe()}};
//# sourceMappingURL=index.js.map
